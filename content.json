{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"fastapi","slug":"python/fastapi","date":"2024-04-02T09:50:13.000Z","updated":"2024-04-02T08:00:38.860Z","comments":true,"path":"2024/04/02/python/fastapi/","permalink":"http://example.com/2024/04/02/python/fastapi/","excerpt":"","text":"fastapi是基于Pydantic库和Starlette框架开发的 Pydanticpython有一个类型提示type hintsPydantic就是基于此，用于数据验证和设置管理。它最初是为了弥补Python标准库在数据验证方面的不足而设计的![[Pasted image 20231229150604.png]] Starlette一种轻量级的ASGI（异步网关接口（_Asynchronous Server Gateway Interface_））框架工具包 请求处理流程一个请求需要经历web服务器和WSGI才能和框架交流数据![[Pasted image 20231229154236.png]] nginx是一个高性能的HTTP和反向代理的web服务器 处理高并发能力是十分强大的，能经受高负 载的考验,有报告表明能支持高达 50,000 个并发连接数。 可以作为静态页面的的服务器，同时也支持CGI协议的动态语言正向代理正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理 简单一点：通过代理服务器来访问服务器的过程 就叫 正向代理。 需要在客户端配置代理服务器进行指定网站访问 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问&#x3D;&#x3D;我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端&#x3D;&#x3D;，此时反向代理服务器和目标服务器对外就是一个服务器，&#x3D;&#x3D;暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。&#x3D;&#x3D; 负载均衡 增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的 情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负 载均衡 客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。![[Pasted image 20231229170712.png]]动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。![[Pasted image 20231229170806.png]] WSGIWeb服务器网关接口（_Python Web Server Gateway Interface_），缩写为WSGI，它是一种专为python定义的接口规范，用于web服务端和web应用（框架）之间的连接，如此web应用可以一起处理一个请求，同时也是基于CGI进行设计的 ![[Pasted image 20231229150650.png]]![[Pasted image 20231229150717.png]] 中间件在正式处理request请求之前先对其进行前置处理&#x3D;&#x3D;注意！request的请求数据只能获取一次，在中间件使用request.body或者request.form获取后在后续处理中就无法获取了&#x3D;&#x3D; 123456789101112131415161718192021222324252627282930313233343536373839定义一个 Middleware 来记录请求信息 @app.middleware(&quot;http&quot;) async def log_request(request: Request, call_next): # 初始化表单对象 form = await request.form() try: # 转换图片文件格式为base64编码 picture = await form.get(&quot;picture&quot;).read() picture_base64 = base64.b64encode(picture).decode(&quot;utf-8&quot;) # 存储请求数据 cached_body = json.dumps(&#123;&quot;picture&quot;: picture_base64, &quot;request_id&quot;: form.get(&quot;request_id&quot;), &quot;create_user_id&quot;: form.get(&quot;create_user_id&quot;), &quot;request_type&quot;: form.get(&quot;request_type&quot;)&#125;) request.scope[&quot;cached_body&quot;] = cached_body # 创建bean对象 bean = RequestLog( request_id=form.get(&#x27;request_id&#x27;), # TODO:存文件地址 request_data=None, request_ip=request.client.host, request_user_id=form.get(&#x27;create_user_id&#x27;), request_type=form.get(&#x27;request_type&#x27;) ) request_log_obj = RequestLogService() result = request_log_obj.create_one(bean) if result: # 继续处理请求 response = await call_next(request) return response else: response = Result(code=4000, msg=&quot;Log Request ERROR&quot;, data=result) return JSONResponse(content=response.to_dict()) except Exception as e: response = Result(code=4000, msg=&quot;Log Request ERROR&quot;, data=None) return JSONResponse(content=response.to_dict())","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2024-03-23T09:46:06.498Z","updated":"2024-03-23T09:46:06.498Z","comments":true,"path":"2024/03/23/hello-world/","permalink":"http://example.com/2024/03/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}